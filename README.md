
#  Algorithm Implementation in Java

##  About This Project
This project contains implementations of fundamental **sorting**, **graph**, and **search** algorithms using Java. It is designed to reinforce algorithmic knowledge and structured coding practices.

---

## 📂 Project Structure
```
AlgorithmProject
│── /src
│   ├── /sorting          # Sorting algorithms
│   │   ├── SelectionSort.java
│   │   ├── InsertionSort.java
│   │   ├── MergeSort.java
│   │   ├── QuickSort.java
│   │   ├── HeapSort.java
│   │   ├── RadixSort.java
│   │   ├── CountingSort.java
│   ├── /graph            # Graph algorithms
│   │   ├── FloydWarshall.java
│   │   ├── PrimMST.java
│   │   ├── KruskalMST.java
│   │   ├── HamiltonianCycle.java
│   ├── /search           # Search algorithms
│   │   ├── LinearSearch.java
│   │   ├── BinarySearch.java
│   ├── /main             # Main execution file
│   │   ├── Main.java
│── README.md             # Project documentation
```

---

## ✨ Implemented Algorithms

### 🔹 Sorting Algorithms
✔️ **SelectionSort.java** – Selection Sort Implementation  
✔️ **InsertionSort.java** – Insertion Sort Implementation  
✔️ **MergeSort.java** – Merge Sort Implementation  
✔️ **QuickSort.java** – Quick Sort Implementation  
✔️ **HeapSort.java** – Heap Sort Implementation  
✔️ **RadixSort.java** – Radix Sort Implementation  
✔️ **CountingSort.java** – Counting Sort Implementation  

### 🔹 Graph Algorithms
✔️ **FloydWarshall.java** – Floyd-Warshall Algorithm (Shortest Paths)  
✔️ **PrimMST.java** – Prim’s Minimum Spanning Tree Algorithm  
✔️ **KruskalMST.java** – Kruskal’s Minimum Spanning Tree Algorithm  
✔️ **HamiltonianCycle.java** – Hamiltonian Cycle Problem Solver  

### 🔹 Search Algorithms
✔️ **LinearSearch.java** – Linear Search Algorithm  
✔️ **BinarySearch.java** – Binary Search Algorithm  

---
## ✅ Summary

| Algorithm | Category | Complexity |
| --- | --- | --- |
| **Selection Sort** | Sorting (Comparison-based) | `O(N²)` |
| **Insertion Sort** | Sorting (Comparison-based) | `O(N²)` |
| **Merge Sort** | Sorting (Divide & Conquer) | `O(N log N)` |
| **Quick Sort** | Sorting (Divide & Conquer) | `O(N log N)` (Average) / `O(N²)` (Worst) |
| **Heap Sort** | Sorting (Heap-based) | `O(N log N)` |
| **Radix Sort** | Sorting (Non-comparison) | `O(Nk)` |
| **Counting Sort** | Sorting (Non-comparison) | `O(N + K)` |
| **Linear Search** | Searching | `O(N)` |
| **Binary Search** | Searching (Only sorted data) | `O(log N)` |
| **Floyd-Warshall** | Graph (All-pairs shortest path) | `O(V³)` |
| **Prim's MST** | Graph (Minimum Spanning Tree) | `O(E log V)` |
| **Kruskal's MST** | Graph (Minimum Spanning Tree) | `O(E log V)` |
| **Hamiltonian Cycle** | Graph (Backtracking) | `O(N!)` |

## ▶How to Run the Project
### 🛠 Prerequisites
- Java Development Kit (JDK) 8 or later
- A Java IDE (IntelliJ IDEA, Eclipse, or VS Code) or command-line tools

### 🏃 Running the Code
To compile and run the project, navigate to the `/src` directory and execute:
```sh
javac main/Main.java
java main.Main
```

---

##  Contributions
Contributions are always welcome! If you have improvements or new algorithms to add, feel free to submit a pull request.



Algorithm Collection in Java

This project is a comprehensive collection of sorting, searching, graph, dynamic programming, greedy, divide and conquer, backtracking, mathematical, and string algorithms implemented in Java. It serves as a structured way to reinforce algorithmic concepts and coding skills.

📂 Implemented Algorithms

🔹 Sorting Algorithms

Selection Sort – Finds the minimum element and places it in order.

Insertion Sort – Builds the sorted array one item at a time.

Merge Sort – A divide-and-conquer sorting algorithm.

Quick Sort – Efficient sorting using partitioning.

Heap Sort – Uses a binary heap for sorting.

Radix Sort – Sorts numbers digit by digit.

Counting Sort – Non-comparative integer sorting.

🔹 Searching Algorithms

Linear Search – Sequentially searches for an element.

Binary Search – Efficient search in sorted arrays.

🔹 Graph Algorithms

Floyd-Warshall Algorithm – Finds shortest paths in a weighted graph.

Prim’s MST Algorithm – Constructs a minimum spanning tree.

Kruskal’s MST Algorithm – Another approach to minimum spanning tree.

Hamiltonian Cycle – Finds a cycle that visits each vertex once.

🔹 Dynamic Programming

Knapsack Problem – Optimized resource allocation.

Longest Common Subsequence – Finds the longest sequence in two strings.

Fibonacci Sequence – Computes Fibonacci numbers using DP.

🔹 Greedy Algorithms

Huffman Coding – Data compression technique.

Activity Selection – Selects maximum number of activities.

🔹 Divide and Conquer Algorithms

Merge Sort – Efficient sorting using recursion.

Quick Sort – Partitioning-based sorting.

🔹 Backtracking Algorithms

N-Queens Problem – Places N queens on a chessboard.

Sudoku Solver – Solves a given Sudoku puzzle.

🔹 Mathematical Algorithms

Greatest Common Divisor (GCD) – Finds the largest divisor of two numbers.

Sieve of Eratosthenes – Efficient prime number generation.

🔹 String Algorithms

KMP Algorithm – Pattern matching in strings.

Rabin-Karp Algorithm – Hash-based string search.

▶️ How to Run the Project

🛠 Prerequisites

Java Development Kit (JDK) 8 or later

A Java IDE (IntelliJ IDEA, Eclipse, or VS Code) or command-line tools

🏃 Running the Code

To compile and run the project, navigate to the /src directory and execute:

javac main/AlgorithmRunner.java
java main.AlgorithmRunner

🤝 Contributions

Contributions are always welcome! If you have improvements or new algorithms to add, feel free to submit a pull request.




